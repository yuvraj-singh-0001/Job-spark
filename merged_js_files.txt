import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\client\postcss.config.js ===
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\client\tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\client\vite.config.js ===
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\server.js ===
// Load environment variables from .env into process.env
require('dotenv').config();

const express = require('express');
const app = express();

// CORS and cookie parsing dependencies
const cors = require('cors');
const cookieParser = require('cookie-parser');

/**
 * applyMiddlewares(app)
 *
 * Purpose:
 *  - Centralize HTTP middleware configuration (CORS, cookie parsing, JSON body parsing).
 *  - Keeps app bootstrap tidy and makes middleware changes easy to manage.
 *
 * Behavior:
 *  - Uses CLIENT_ORIGIN environment variable as the allowed origin (fallback to http://localhost:5173).
 *  - Only allows requests from the allowlist or from tools with no origin (e.g., server-to-server or curl).
 *  - Enables credentials so cookies (HttpOnly cookies) can be sent cross-origin.
 *  - Configures allowed methods and headers for preflight responses.
 */
function applyMiddlewares(app) {
  // Where the frontend is expected to be served from
  const CLIENT_ORIGIN = process.env.CLIENT_ORIGIN || 'http://localhost:5173';

  // Use a Set for O(1) lookups (makes it easy to add more allowed origins later)
  const allowlist = new Set([CLIENT_ORIGIN]);

  // CORS options object passed to cors()
  const corsOptions = {
    // origin is a function so we can dynamically allow certain origins
    origin(origin, callback) {
      // If origin is falsy (e.g., same-origin requests or tools like curl) allow it.
      // Otherwise only allow origins explicitly in the allowlist.
      if (!origin || allowlist.has(origin)) return callback(null, true);
      // Reject others — the error will surface as CORS failure in the browser.
      return callback(new Error('Not allowed by CORS'));
    },

    // Allow cookies to be included in cross-origin requests (frontend must use fetch/axios with credentials)
    credentials: true,

    // Allowed HTTP methods for CORS preflight
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],

    // Allowed headers for cross-origin requests
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin'],

    // Status to return for successful OPTIONS requests in some legacy browsers
    optionsSuccessStatus: 204,
  };

  // Attach configured middleware to the express app
  app.use(cors(corsOptions));   // handle CORS
  app.use(cookieParser());      // parse cookies (populates req.cookies)
  app.use(express.json());      // parse JSON request bodies (populates req.body)
}

// Install middleware
applyMiddlewares(app);

// Health-check endpoint for load balancers / uptime checks
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

/**
 * Mount application routes.
 * The router is required inside a try/catch so the server can still start
 * even if router fails to load during development (helps debugging).
 *
 * In production you may want to fail fast instead of continuing to listen.
 */
try {
  const router = require('./src/routes/router');
  app.use('/api', router);
} catch (e) {
  // Helpful development log — includes the error message so you know why require failed
  console.error('Failed to load router:', e.message || e);
}

// Listen on the configured port
const PORT = process.env.PORT || 5174;
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
});

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\auth\users\logout.js ===
// src/api/auth/logout.js
async function  logout(req, res) {
  try {
    const isProd = process.env.NODE_ENV === 'production';
    // Clear cookie by using clearCookie with same options used when setting it
    res.clearCookie('token', {
      httpOnly: true,
      secure: isProd,
      sameSite: isProd ? 'none' : 'lax',
      path: '/',
    });

    return res.json({ message: 'Logged out' });
  } catch (err) {
    console.error('Logout error', err);
    return res.status(500).json({ message: 'Internal server error' });
  }
};
module.exports = logout;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\auth\users\sign-in.js ===
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const pool = require('../../config/db');

/**
 * signToken(payload)
 * -------------------
 * Helper function to generate a JSON Web Token.
 * - payload: data stored inside the token (user ID, username, role).
 * - expiresIn: defaults to 7 days if not provided.
 */
function signToken(payload) {
  const secret = process.env.JWT_SECRET;
  const expiresIn = process.env.JWT_EXPIRES_IN || '7d';
  return jwt.sign(payload, secret, { expiresIn });
}

/**
 * POST /api/auth/login
 * ---------------------
 * Steps:
 * 1. Validate body input.
 * 2. Fetch user by email or username.
 * 3. Compare input password with stored password hash.
 * 4. Generate JWT token.
 * 5. Set authentication cookie.
 * 6. Return logged-in user details.
 */
async function signIn(req, res) {
  try {
    const { identifier, password } = req.body || {};

    // identifier can be email OR username
    if (!identifier || !password) {
      return res.status(400).json({ message: 'identifier (email or username) and password are required' });
    }

    // Get DB connection from pool
    const conn = await pool.getConnection();
    try {
      /**
       * Step 1: Look up user by email or username
       * -----------------------------------------
       * Using OR makes login flexible.
       */
      const [rows] = await conn.execute(
        'SELECT id, username, email, role, password_hash FROM users WHERE email = ? OR username = ? LIMIT 1',
        [identifier, identifier]
      );

      // User not found
      if (!rows.length) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }

      const userRow = rows[0];

      /**
       * Step 2: Compare input password with stored hash
       * ------------------------------------------------
       * bcrypt.compare() returns true if passwords match.
       */
      const valid = await bcrypt.compare(password, userRow.password_hash);
      if (!valid) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }

      /**
       * Step 3: Prepare safe user object (never send password_hash)
       */
      const user = {
        id: userRow.id,
        username: userRow.username,
        email: userRow.email,
        role: userRow.role,
      };

      /**
       * Step 4: Generate JWT token
       * ---------------------------
       * Payload includes:
       *  - sub (ID)
       *  - username
       *  - role
       */
      const token = signToken({
        sub: user.id,
        username: user.username,
        role: user.role,
      });

      /**
       * Step 5: Set secure HttpOnly cookie
       * ----------------------------------
       * - httpOnly: JS cannot read it (protects against XSS)
       * - secure: only works over HTTPS in production
       * - sameSite:
       *     - "none" for cross-site cookies in production
       *     - "lax" for local development
       */
      const isProd = process.env.NODE_ENV === 'production';
      res.cookie('token', token, {
        httpOnly: true,
        secure: isProd,
        sameSite: isProd ? 'none' : 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      return res.json({
        user,
        token,
        message: 'Login successful',
      });

    } finally {
      // Always release DB connection
      conn.release();
    }

  } catch (err) {
    console.error('Login error', err);
    return res.status(500).json({ message: 'Internal server error' });
  }
}

module.exports = signIn;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\auth\users\sign-up.js ===
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const pool = require('../../config/db');

/**
 * signToken(payload)
 * -------------------
 * Utility function to generate a signed JSON Web Token.
 *
 * - payload: Data we store in the token (sub, username, role).
 * - secret: Loaded from environment variable JWT_SECRET.
 * - expiresIn: Token expiry (default 7 days).
 */
function signToken(payload) {
  const secret = process.env.JWT_SECRET;
  const expiresIn = process.env.JWT_EXPIRES_IN || '7d';
  return jwt.sign(payload, secret, { expiresIn });
}

/**
 * POST /api/auth/signup
 * ----------------------
 * Steps:
 * 1. Validate required input fields.
 * 2. Enforce role safety (only "recruiter" or default to "user").
 * 3. Get DB connection from pool.
 * 4. Check if user already exists (email OR username).
 * 5. Hash the password using bcrypt.
 * 6. Insert new user into database.
 * 7. Generate JWT token for authentication.
 * 8. Set HttpOnly cookie containing the token.
 * 9. Return newly created user.
 */
async function signUp(req, res) {
  try {
    // Extract fields from request body
    const { username, email, password, role: inputRole } = req.body || {};

    // Basic input validation
    if (!username || !email || !password) {
      return res.status(400).json({ message: 'username, email and password are required' });
    }

    // Prevent clients from setting arbitrary roles
    const role = (inputRole === 'recruiter' ? 'recruiter' : 'user');

    // Get a DB connection from the pool
    const conn = await pool.getConnection();
    try {
      /**
       * Step 1: Check if user already exists
       * -------------------------------------
       * Using OR condition so user cannot reuse
       * duplicate email or username.
       */
      const [existing] = await conn.execute(
        'SELECT id FROM users WHERE email = ? OR username = ? LIMIT 1',
        [email, username]
      );

      if (existing.length) {
        return res.status(409).json({ message: 'User already exists' });
      }

      /**
       * Step 2: Hash password
       * ----------------------
       * bcrypt.hash(password, 10)
       *  - 10 rounds of salting (standard strength)
       */
      const passwordHash = await bcrypt.hash(password, 10);

      /**
       * Step 3: Insert new user
       * ------------------------
       * Store hashed password, not plain text.
       */
      const [result] = await conn.execute(
        'INSERT INTO users (username, email, password_hash, role) VALUES (?, ?, ?, ?)',
        [username, email, passwordHash, role]
      );

      // Build user object for frontend response
      const user = { id: result.insertId, username, email, role };

      /**
       * Step 4: Generate token
       * ------------------------
       * Token contains:
       *  - sub: user ID
       *  - username
       *  - role
       */
      const token = signToken({
        sub: user.id,
        username: user.username,
        role: user.role,
      });

      /**
       * Step 5: Set cookie
       * -------------------
       * Secure cookie settings:
       *  - httpOnly: cannot be accessed via JS (prevents XSS)
       *  - secure: only HTTPS in production
       *  - sameSite:
       *      "none" for cross-site cookies in production
       *      "lax" for local dev
       */
      const isProd = process.env.NODE_ENV === 'production';
      res.cookie('token', token, {
        httpOnly: true,
        secure: isProd,
        sameSite: isProd ? 'none' : 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      // Final response
      return res.status(201).json({
        user,
        token,
        message: 'Signup successful',
      });
    } finally {
      // Always release connection back to pool
      conn.release();
    }
  } catch (err) {
    console.error('Signup error', err);
    return res.status(500).json({ message: 'Internal server error' });
  }
}

module.exports = signUp;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\auth\users\update.js ===
const pool = require('../../config/db');

async function updateProfile(req, res) {
  try {
    const userId = req.user && req.user.id;
    if (!userId) return res.status(401).json({ message: 'Unauthorized' });

    const allowed = ['username', 'email', 'name'];
    const payload = req.body || {};
    const requested = Object.keys(payload).filter(k => allowed.includes(k));
    if (!requested.length) return res.status(400).json({ message: 'No valid fields to update' });

    const conn = await pool.getConnection();
    try {
      // Get actual columns present in users table
      const [cols] = await conn.query('SHOW COLUMNS FROM users');
      const colNames = cols.map(c => c.Field);

      // Only update fields that actually exist
      const toUpdate = requested.filter(f => colNames.includes(f));
      if (!toUpdate.length) return res.status(400).json({ message: 'No updatable fields available' });

      const setParts = toUpdate.map(f => `${f} = ?`).join(', ');
      const values = toUpdate.map(f => payload[f]);
      values.push(userId);

      const sql = `UPDATE users SET ${setParts} WHERE id = ?`;
      await conn.execute(sql, values);

      // Build select list to return updated user
      const base = ['id','username','email','role'];
      const optional = ['name','created_at','last_login'].filter(c => colNames.includes(c));
      const selectCols = base.concat(optional).join(', ');
      const [rows] = await conn.execute(`SELECT ${selectCols} FROM users WHERE id = ? LIMIT 1`, [userId]);
      if (!rows.length) return res.status(404).json({ message: 'User not found' });

      return res.json({ user: rows[0] });
    } finally {
      conn.release();
    }
  } catch (err) {
    console.error('Update profile error', err);
    return res.status(500).json({ message: 'Internal server error' });
  }
}

module.exports = updateProfile;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\config\db.js ===
const mysql = require('mysql2/promise');

/**
 * MySQL Connection Pool
 * ----------------------
 * Purpose:
 *   - Create a reusable pool of MySQL connections.
 *   - Avoid opening a new DB connection for every request (better performance).
 *   - Use async/await because mysql2/promise is being used.
 *
 * Environment Variables (loaded from .env):
 *   - DB_HOST: Database server hostname
 *   - DB_USER: Username for DB authentication
 *   - DB_PASSWORD: Password for DB authentication
 *   - DB_NAME: Database name to connect to
 *
 * Options:
 *   waitForConnections: true
 *       → Queue incoming requests when all connections are busy.
 *
 *   connectionLimit: 10
 *       → Max number of active connections allowed in the pool at once.
 *         (Customize based on server resources.)
 *
 *   queueLimit: 0
 *       → 0 = unlimited queued connection requests.
 */
const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

// Export pool so other files can run queries using:
// const [rows] = await pool.query("SELECT * FROM users");
module.exports = pool;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\jobs\get-jobdetails.js ===
// api/jobs/get-job.js
const express = require('express');
const pool = require('../config/db');
const router = express.Router();

async function getjobdetails(req, res)  {
  try {
    const id = parseInt(req.params.id, 10);
    if (Number.isNaN(id)) return res.status(400).json({ ok: false, message: 'Invalid job id' });

    const sql = `
      SELECT
        id,
        title,
        company,
        job_type,
        city,
        locality,
        min_experience,
        max_experience,
        salary,
        vacancies,
        description,
        logo_path,
        created_at,
        contact_email,
        contact_phone,
        interview_address
      FROM jobs
      WHERE id = ?
      LIMIT 1
    `;
    const [rows] = await pool.query(sql, [id]);
    if (!rows || rows.length === 0) return res.status(404).json({ ok: false, message: 'Job not found' });

    const r = rows[0];
    let experiance = 'Not specified';
    if (r.min_experience == null && r.max_experience == null) experiance = 'Fresher';
    else if (r.min_experience != null && r.max_experience == null) experiance = `${r.min_experience}+ yrs`;
    else if (r.min_experience == null && r.max_experience != null) experiance = `Up to ${r.max_experience} yrs`;
    else experiance = `${r.min_experience}-${r.max_experience} yrs`;

    // fetch tags from tag tables if available (silent fallback)
    let tags = [];
    try {
      const [tagRows] = await pool.query(
        `SELECT jtm.job_id, jt.name as tag FROM job_tag_map jtm JOIN job_tags jt ON jt.id = jtm.tag_id WHERE jtm.job_id = ?`,
        [id]
      );
      tags = tagRows.map(tr => tr.tag);
    } catch (e) {
      // ignore if tag tables aren't present
    }

    const job = {
      id: r.id,
      title: r.title,
      company: r.company,
      type: r.job_type || 'Full-time',
      location: r.city + (r.locality ? `, ${r.locality}` : ''),
      tags: tags.length ? tags : (r.skills || '').split(',').map(s => s.trim()).filter(Boolean),
      salary: r.salary || null,
      vacancies: r.vacancies,
      description: r.description,
      logoPath: r.logo_path || null,
      createdAt: r.created_at,
      experiance,
      min_experience: r.min_experience,
      max_experience: r.max_experience,
      contactEmail: r.contact_email || null,
      contactPhone: r.contact_phone || null,
      interviewAddress: r.interview_address || null,
    };

    res.json({ ok: true, job });
  } catch (err) {
    console.error('GET /api/jobs/:id error:', err);
    res.status(500).json({ ok: false, message: 'Internal Server Error' });
  }
};
module.exports = getjobdetails;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\jobs\get-jobs.js ===
// api/jobs/list-jobs.js
const express = require('express');
const pool = require('../config/db'); // path relative to this file
const router = express.Router();

function parseSkills(skills) {
  if (!skills) return [];
  return skills.split(',').map(s => s.trim()).filter(Boolean);
}

async function getjobs (req, res) {
  try {
    const limit = Math.max(1, Math.min(100, parseInt(req.query.limit || '10', 10)));
    const sql = `
      SELECT
        id,
        title,
        company,
        job_type,
        city,
        locality,
        min_experience,
        max_experience,
        salary,
        vacancies,
        description,
        logo_path,
        created_at
      FROM jobs
      ORDER BY created_at DESC
      LIMIT ?
    `;
    const [rows] = await pool.query(sql, [limit]);

    // Fetch tags from normalized tables when available (silent fallback)
    let tagMap = {};
    if (Array.isArray(rows) && rows.length) {
      try {
        const ids = rows.map((r) => r.id);
        const placeholders = ids.map(() => '?').join(',');
        const tagSql = `SELECT jtm.job_id, jt.name as tag FROM job_tag_map jtm JOIN job_tags jt ON jt.id = jtm.tag_id WHERE jtm.job_id IN (${placeholders})`;
        const [tagRows] = await pool.query(tagSql, ids);
        tagRows.forEach((tr) => {
          tagMap[tr.job_id] = tagMap[tr.job_id] || [];
          tagMap[tr.job_id].push(tr.tag);
        });
      } catch (e) {
        // silently ignore missing tag tables or errors
      }
    }

    const jobs = rows.map(r => {
      let experiance = 'Not specified';
      if (r.min_experience == null && r.max_experience == null) experiance = 'Fresher';
      else if (r.min_experience != null && r.max_experience == null) experiance = `${r.min_experience}+ yrs`;
      else if (r.min_experience == null && r.max_experience != null) experiance = `Up to ${r.max_experience} yrs`;
      else experiance = `${r.min_experience}-${r.max_experience} yrs`;

      return {
        id: r.id,
        title: r.title,
        company: r.company,
        type: r.job_type || 'Full-time',
        location: r.city + (r.locality ? `, ${r.locality}` : ''),
        tags: tagMap[r.id] || parseSkills(r.skills || r.tags || r.skill || ''),
        salary: r.salary || null,
        vacancies: r.vacancies,
        description: r.description,
        logoPath: r.logo_path || null,
        createdAt: r.created_at,
        experiance,
      };
    });

    res.json({ ok: true, jobs });
  } catch (err) {
    console.error('GET /api/jobs error:', err);
    try {
      const fs = require('fs');
      const path = require('path');
      const dbgPath = path.join(__dirname, '../../../debug_jobs.log');
      const now = new Date().toISOString();
      fs.appendFileSync(dbgPath, `${now} - ERROR: ${err && err.stack ? err.stack : String(err)}\n`);
    } catch (e) {
      // ignore file logging errors
    }
    res.status(500).json({ ok: false, message: 'Internal Server Error' });
  }
};

module.exports = getjobs;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\api\recruiter\hire-jobs\create-job.js ===
const multer = require("multer");
const path = require("path");
const fs = require("fs");
const pool = require("../../config/db");

// ensure uploads dir exists
const UPLOAD_DIR = path.join(__dirname, "..", "..", "..", "uploads", "logos");
fs.mkdirSync(UPLOAD_DIR, { recursive: true });

// multer storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, UPLOAD_DIR),
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const name = `${Date.now()}-${Math.round(Math.random() * 1e9)}${ext}`;
    cb(null, name);
  },
});
const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    if (!file.mimetype.startsWith("image/")) return cb(new Error("Only image files allowed"), false);
    cb(null, true);
  },
});

async function createJobHandler(req, res) {
  // Apply multer middleware for single file upload
  const uploadMiddleware = upload.single("logo");
  uploadMiddleware(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ ok: false, message: err.message });
    }
    try {
      // fields from your frontend form (camelCase)
      const {
        title = "",
        company = "",
        jobType = "Full-time",
        city = "",
        locality = "",
        minExperience = null,
        maxExperience = null,
        salary = "",
        vacancies = "1",
        description = "",
        interviewAddress = "",
        contactEmail = "",
        contactPhone = "",
      } = req.body;

      // simple validation
      const errors = [];
      if (!title.trim()) errors.push("title is required");
      if (!company.trim()) errors.push("company is required");
      if (!city.trim()) errors.push("city is required");
      if (!description.trim()) errors.push("description is required");
      if (!contactEmail.trim() && !contactPhone.trim()) errors.push("provide email or phone");

      if (errors.length) return res.status(400).json({ ok: false, errors });

      // prepare values to insert
      const logoPath = req.file ? path.posix.join("uploads", "logos", req.file.filename) : null;

      // convert numeric fields carefully
      const minExpNum = minExperience === null || minExperience === "" ? null : Number(minExperience);
      const maxExpNum = maxExperience === null || maxExperience === "" ? null : Number(maxExperience);
      const vacanciesNum = vacancies ? Math.max(1, parseInt(vacancies, 10) || 1) : 1;

      // Insert into DB (use placeholders)
      // Note: 'jobs' table columns - skills column doesn't exist, use job_tag_map for tags
      const sql = `
        INSERT INTO jobs
          (title, company, job_type, city, locality, min_experience, max_experience, salary, vacancies, description, interview_address, contact_email, contact_phone, logo_path, recruiter_id, posted_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
      `;

      // recruiter_id would come from auth; for now use null
      const recruiterId = null;

      const params = [
        title,
        company,
        jobType,
        city,
        locality || null,
        minExpNum,
        maxExpNum,
        salary || null,
        vacanciesNum,
        description,
        interviewAddress || null,
        contactEmail || null,
        contactPhone || null,
        logoPath,
        recruiterId,
      ];

      const [result] = await pool.query(sql, params);
      const jobId = result.insertId;

      // Insert skills as tags if provided
      if (req.body.skills && typeof req.body.skills === 'string' && req.body.skills.trim()) {
        try {
          const skillList = req.body.skills.split(',').map(s => s.trim()).filter(Boolean);
          for (const skillName of skillList) {
            // Insert tag if not exists, get its ID
            const [tagRows] = await pool.query(
              `INSERT INTO job_tags (name) VALUES (?) ON DUPLICATE KEY UPDATE id=LAST_INSERT_ID(id)`,
              [skillName]
            );
            const tagId = tagRows.insertId || (await pool.query(`SELECT id FROM job_tags WHERE name = ?`, [skillName]))[0][0].id;
            // Link job to tag
            await pool.query(`INSERT IGNORE INTO job_tag_map (job_id, tag_id) VALUES (?, ?)`, [jobId, tagId]);
          }
        } catch (e) {
          // if tag insertion fails, still return success (job was created)
          console.error('Error saving skills as tags:', e.message);
        }
      }

      return res.status(201).json({
        ok: true,
        id: jobId,
        message: "Job created",
        logoPath,
      });
    } catch (err) {
      console.error("createJob error:", err);
      // if multer error, it may be in err.code or err.message
      return res.status(500).json({ ok: false, message: err.message || "Internal Server Error" });
    }
  });
}

module.exports = createJobHandler;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\controllers\auth\admire\index.js ===

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\controllers\auth\recruiter\hire-jobs\create-jobs\index.js ===
const express = require("express");
const router = express.Router();

const createJob = require("../../../../../api/recruiter/hire-jobs/create-job");
// POST /api/admin/jobs
router.post("/", createJob);

module.exports = router;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\controllers\auth\recruiter\recruter-premier\index.js ===

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\controllers\auth\users\index.js ===
const express = require('express');
const router = express.Router();
const logout = require('../../../api/auth/users/logout');
const updateProfile = require('../../../api/auth/users/update');
/**
 * Import Auth Handlers
 * ---------------------
 * These handlers contain the actual logic for signup and login.
 * They live in: src/api/auth/users/
 *
 * signUp  → Creates new user, hashes password, saves to DB, sets cookie.
 * signIn  → Validates credentials, checks DB, issues JWT cookie.
 */
const signUp = require('../../../api/auth/users/sign-up');
const signIn = require('../../../api/auth/users/sign-in');

/**
 * Auth Middleware
 * ----------------
 * requireAuth  → Ensures that the incoming request has a valid JWT cookie.
 * authCheck    → Returns the decoded user data stored in req.user.
 */
const { requireAuth, authCheck } = require('../../../middlewares/auth');

/**
 * Route Mount Point
 * ------------------
 * This file is mounted at /api/auth in routes/router.js:
 * 
 *     app.use('/api/auth', index)
 *
 * So the final endpoints become:
 *   POST   /api/auth/signup
 *   POST   /api/auth/login
 *   GET    /api/auth/authcheck
 *   ( optional alias ) /api/auth/me
 */

// Create new user
router.post('/signup', signUp);

// Login user and issue JWT cookie
router.post('/login', signIn);

// Validate token + return currently authenticated user
router.get('/authcheck', requireAuth, authCheck);

// Alias if you want cleaner endpoint:
router.get('/me', requireAuth, authCheck);
// Update profile (authenticated)
router.put('/me', requireAuth, updateProfile);
// Logout user by clearing the cookie
router.post('/logout', logout);

module.exports = router;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\controllers\jobs\index.js ===
// routes/jobs.js - expose job APIs at the router root
const express = require("express");
const getjobs = require("../../api/jobs/get-jobs");
const getjobdetails = require("../../api/jobs/get-jobdetails");
const router = express.Router();

// Mount at root so when main router uses router.use('/jobs', thisRouter):
//   GET / maps to /api/jobs (list jobs)
//   GET /:id maps to /api/jobs/:id (single job)
router.get("/", getjobs);
router.get("/:id", getjobdetails);

module.exports = router;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\controllers\recruiter\hire-jobs\index.js ===
const express = require('express');
const router = express.Router();

// Import job creation handler
const createJob = require('../../../api/recruiter/hire-jobs/create-job');

// POST /api/recruiter/jobs/create
router.post('/create', createJob);

module.exports = router;

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\middlewares\auth.js ===
// GET /api/auth/me - Validate cookie and return user info from JWT
const jwt = require('jsonwebtoken');

/**
 * Middleware: requireAuth
 * -----------------------
 * Purpose:
 *   - Check if a JWT token exists in cookies.
 *   - Verify the token using JWT_SECRET.
 *   - Attach decoded user information to req.user.
 *   - If token is missing or invalid → block request with 401 Unauthorized.
 *
 * Flow:
 *   1. Read token from req.cookies.token.
 *   2. If token not found → return 401.
 *   3. Verify token → decode payload.
 *   4. Store user information in req.user.
 *   5. Call next() to continue to protected route.
 */
function requireAuth(req, res, next) {
  try {
    // Extract token from cookies
    const token = req.cookies?.token;

    // If no token found, block access
    if (!token) return res.status(401).json({ message: 'Unauthorized' });

    // Verify token and extract payload
    const payload = jwt.verify(token, process.env.JWT_SECRET);

    // Attach essential user details to req.user for use in next handlers
    // Include token issuance time (iat) as loginAt so frontend can show login time
    req.user = {
      id: payload.sub,
      username: payload.username,
      role: payload.role,
      loginAt: payload.iat ? new Date(payload.iat * 1000).toISOString() : undefined,
    };

    return next(); // Move to the next middleware/controller
  } catch (err) {
    // Token expired or invalid
    return res.status(401).json({ message: 'Unauthorized' });
  }
}

/**
 * Handler: authCheck
 * -------------------
 * Purpose:
 *   - Return the currently authenticated user's data.
 *   - This handler must run after requireAuth middleware.
 *
 * Flow:
 *   1. Check if req.user exists.
 *   2. If not → return 401.
 *   3. Send user object in response.
 */
function authCheck(req, res) {
  if (!req.user) return res.status(401).json({ message: 'Unauthorized' });

  // Send user info to frontend
  return res.json({ user: req.user });
}

module.exports = { requireAuth, authCheck };

--- END OF FILE ---

=== FILE: C:\Users\YUVRAJ\Desktop\Job-spark\server\src\routes\router.js ===
const express = require('express');
const router = express.Router();
const recruiterJobRoutes = require('../controllers/recruiter/hire-jobs/index');
const jobsRouter = require('../controllers/jobs/index');

// AUTH
const authRoutes = require('../controllers/auth/users/index');
router.use('/auth', authRoutes);
// Recruiter jobs
router.use('/recruiter/jobs', recruiterJobRoutes);
// Jobs
router.use('/jobs', jobsRouter);

module.exports = router;

--- END OF FILE ---


=== END OF MERGE (Total files: 21) ===
